# Vishlist — Социальный вишлист

Веб-приложение для создания списков желаний и координации подарков между друзьями. Владелец создаёт вишлист, делится ссылкой — друзья бронируют подарки и скидываются, не раскрывая сюрприз.

**[Открыть приложение →](https://vishlist-lyart.vercel.app/)**

---

## Стек

| Слой | Технология |
|------|-----------|
| Frontend | Next.js 15, React 19, Tailwind CSS v4, React Query, Zustand, Radix UI, Framer Motion |
| Backend | FastAPI (async), SQLAlchemy 2.0 (async), Alembic, asyncpg |
| База данных | PostgreSQL |
| Авторизация | JWT + Google OAuth |
| Realtime | WebSocket |
| Изображения | Vercel Blob |
| Деплой | Vercel (frontend) + Railway (backend + PostgreSQL) |

---

## Возможности

- **Вишлисты** — несколько списков желаний с эмодзи-иконкой, датой события и описанием
- **Товары** — название, ссылка, цена, фото, заметка. Drag-and-drop сортировка
- **Автозаполнение по ссылке** — вставляешь URL товара → название, картинка и цена подтягиваются автоматически
- **Публичная ссылка** — друзья открывают вишлист без регистрации
- **Бронирование подарков** — друг вводит только имя и бронирует. Владелец не видит кто — сюрприз сохранён
- **Групповые сборы** — несколько друзей скидываются на дорогой подарок, прогресс-бар показывает сколько собрано
- **Realtime** — бронирования и вклады обновляются мгновенно через WebSocket
- **Google OAuth** — вход в один клик, автоматическое объединение с email-аккаунтом
- **Шаринг** — нативное меню «Поделиться» на телефоне, копирование ссылки на десктопе
- **Адаптивность** — мобильная версия с bottom sheets и нативным поведением
- **Кастомный дизайн** — собственная палитра, шрифты, favicon. Не дефолтный Tailwind

---

## Продуктовые решения

> Помечено: **[ТЗ]** — требование из задания, **[Моё]** — продуктовое решение, которое я придумал сам.

### Гостевой доступ без барьеров [Моё]

Друг открывает ссылку и бронирует подарок, введя только имя. Никакой регистрации.

После бронирования — экран с необязательным полем email: «Куда отправить подтверждение?». Email запрашивается **после** действия, не до — как в магазинах «отправить чек на почту?». Не блокирует бронирование.

Если email указан — гость получит письмо со ссылкой для отмены. Если нет — управление через localStorage. Потерял — кнопка «Я уже бронировал тут» → ввод email → восстановление доступа через signed JWT (без отдельной таблицы в БД).

### Приватность владельца [Моё]

**[ТЗ]** говорит: «владелец не видит кто что зарезервировал» и «не видит кто сколько скинул». Конкретную реализацию я спроектировал сам:

| | Владелец | Друзья |
|---|---|---|
| Статус товара | «Доступен» / «Забронирован» / «Сбор 60%» / «Собрано!» | То же + имена |
| Кто забронировал | **Не видит** (сюрприз!) | Видит имя — для координации |
| Кто скинулся | Только кол-во участников + общая сумма | Имена + суммы каждого |

Друзья видят друг друга, чтобы координироваться между собой. Владелец — только статусы.

### Групповые сборы [Моё]

- Нет минимального вклада — любая сумма. Это социальный инструмент, не платёжная система
- Пресеты быстрого ввода: 500 ₽, 1 000 ₽, 2 000 ₽, «Вся сумма»
- Максимум ввода = остаток. При 100% — бейдж «Собрано!»
- Сумма не набрана? Ничего не блокируется. Владелец видит «Сбор: 45%» и сам решает
- Первый вклад определяет режим: скинулись → полное бронирование невозможно. Все отменили → товар снова доступен

### Undo вместо подтверждений [Моё]

Удаление — без диалогов «Вы уверены?». Действие выполняется сразу, внизу toast «Удалено · **Отменить**» на 5 секунд.

Снятие брони — отложенный запрос: DELETE уходит на сервер только через 5 секунд. «Отменить» отзывает до отправки. Паттерн как в Gmail.

### Двухшаговая модалка бронирования [Моё]

**Гость:** имя → «Забронировать» → confetti → success-экран с опциональным email.
**Залогиненный:** «Забронировать от имени Иван?» → кнопка → confetti. Без лишних полей.

### Ещё решения [Моё]

- **Slug с транслитерацией:** «День рождения» → `/w/den-rozhdeniya`. Immutable — при редактировании названия ссылка не меняется
- **Обратный отсчёт:** «До дня рождения осталось 12 дней» — создаёт срочность. Дата прошла — отсчёт скрыт
- **Баннер для владельца:** если владелец открывает свою публичную ссылку — «Это ваш вишлист · Редактировать →», кнопки бронирования скрыты
- **Архивация:** публичная ссылка работает, но бронировать нельзя. Владелец сам решает когда архивировать
- **RSC + двухэтапная загрузка:** данные на сервере (мгновенный рендер), клиент дозагружает guest_token (~200ms)
- **WS без персональных данных:** только тип события + ID, клиент рефетчит через API с фильтрацией по роли
- **guest_token per-wishlist:** изолирован по вишлисту, активность не пересекается

---

## Что если что-то пойдёт не так?

| Что может пойти не так | Что происходит |
|------------------------|----------------|
| Два друга бронируют один товар одновременно | Первый получает бронь, второй мгновенно видит «Уже забронирован» — уникальный constraint на уровне БД |
| Сумма вкладов превышает цену товара | Транзакция с блокировкой строки — вклад принимается только если остаток позволяет, иначе ошибка с указанием максимума |
| Один бронирует, другой скидывается одновременно | Блокировка на уровне строки — первая операция проходит, вторая получает конфликт |
| Владелец пытается забронировать свой товар | Кнопки бронирования скрыты, API возвращает 403 |
| Бронирование в архивном вишлисте | Кнопки скрыты, бейдж «Архив», API возвращает 403 |
| Удаление товара, на который уже скинулись | Мягкое удаление + undo-toast 5 секунд. Данные не теряются |
| Удаление вишлиста целиком | Мягкое удаление + undo. Подключённые клиенты получают уведомление через WebSocket |
| Владелец меняет цену после начала сбора | Прогресс пересчитывается. Если новая цена ≤ собранной — автоматически «Собрано!» |
| Гость потерял доступ (очистил браузер) | Кнопка «Я уже бронировал тут» → ввод email → ссылка для восстановления на почту |
| Email в разном регистре (Ivan@Mail.ru vs ivan@mail.ru) | Приводится к нижнему регистру при сохранении — дубликатов не будет |
| Вход через Google, а аккаунт с таким email уже есть | Аккаунты объединяются — Google OAuth привязывается к существующему, дубликат не создаётся |
| XSS через имя гостя | HTML-теги вырезаются, лимит 50 символов, React экранирует вывод |
| SSRF через URL-парсер (ссылка на внутренний сервер) | Приватные IP заблокированы, редиректы проверяются, таймаут 5 сек, лимит 1 МБ |
| Битая картинка товара | Вместо сломанной иконки — заглушка в стиле приложения |

---

## Локальный запуск

### Требования
- Node.js 18+, Python 3.12+, PostgreSQL

### Backend

```bash
cd backend
python -m venv .venv && source .venv/bin/activate
pip install -r requirements.txt
cp .env.example .env  # заполнить DATABASE_URL, SECRET_KEY
alembic upgrade head
uvicorn app.main:app --reload
```

### Frontend

```bash
cd frontend
npm install
cp .env.example .env.local  # заполнить NEXT_PUBLIC_API_URL
npm run dev
```

Приложение: [localhost:3000](http://localhost:3000) · API: [localhost:8000/docs](http://localhost:8000/docs)

---

## Архитектура

```
frontend/          Next.js 15 (App Router, RSC + Client Components)
├── app/           Страницы и layouts
├── components/    UI-компоненты (переиспользуемые)
├── hooks/         React-хуки (useAuth, useRealtime, useGuestToken...)
├── lib/           API-клиент, WebSocket, утилиты
└── types/         TypeScript-типы

backend/           FastAPI (async)
├── app/api/       Endpoints (auth, wishlists, items, reservations...)
├── app/core/      Config, security, database
├── app/models/    SQLAlchemy-модели
├── app/schemas/   Pydantic v2 схемы
├── app/utils/     URL-парсер, WebSocket manager, slug, email
└── alembic/       Миграции
```
